//// [tests/cases/compiler/inferTypePredicates.ts] ////

=== inferTypePredicates.ts ===
// https://github.com/microsoft/TypeScript/issues/16069

const numsOrNull = [1, 2, 3, 4, null];
>numsOrNull : Symbol(numsOrNull, Decl(inferTypePredicates.ts, 2, 5))

const filteredNumsTruthy: number[] = numsOrNull.filter(x => !!x); // should error
>filteredNumsTruthy : Symbol(filteredNumsTruthy, Decl(inferTypePredicates.ts, 3, 5))
>numsOrNull.filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>numsOrNull : Symbol(numsOrNull, Decl(inferTypePredicates.ts, 2, 5))
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>x : Symbol(x, Decl(inferTypePredicates.ts, 3, 55))
>x : Symbol(x, Decl(inferTypePredicates.ts, 3, 55))

const filteredNumsNonNullish: number[] = numsOrNull.filter(x => x !== null); // should ok
>filteredNumsNonNullish : Symbol(filteredNumsNonNullish, Decl(inferTypePredicates.ts, 4, 5))
>numsOrNull.filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>numsOrNull : Symbol(numsOrNull, Decl(inferTypePredicates.ts, 2, 5))
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>x : Symbol(x, Decl(inferTypePredicates.ts, 4, 59))
>x : Symbol(x, Decl(inferTypePredicates.ts, 4, 59))

const evenSquaresInline: number[] = // should error
>evenSquaresInline : Symbol(evenSquaresInline, Decl(inferTypePredicates.ts, 6, 5))

    [1, 2, 3, 4]
>[1, 2, 3, 4]        .map(x => x % 2 === 0 ? x * x : null)        .filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>[1, 2, 3, 4]        .map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))

        .map(x => x % 2 === 0 ? x * x : null)
>map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>x : Symbol(x, Decl(inferTypePredicates.ts, 8, 13))
>x : Symbol(x, Decl(inferTypePredicates.ts, 8, 13))
>x : Symbol(x, Decl(inferTypePredicates.ts, 8, 13))
>x : Symbol(x, Decl(inferTypePredicates.ts, 8, 13))

        .filter(x => !!x); // tests truthiness, not non-nullishness
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>x : Symbol(x, Decl(inferTypePredicates.ts, 9, 16))
>x : Symbol(x, Decl(inferTypePredicates.ts, 9, 16))

const isTruthy = (x: number | null) => !!x;
>isTruthy : Symbol(isTruthy, Decl(inferTypePredicates.ts, 11, 5))
>x : Symbol(x, Decl(inferTypePredicates.ts, 11, 18))
>x : Symbol(x, Decl(inferTypePredicates.ts, 11, 18))

const evenSquares: number[] =  // should error
>evenSquares : Symbol(evenSquares, Decl(inferTypePredicates.ts, 13, 5))

    [1, 2, 3, 4]
>[1, 2, 3, 4]    .map(x => x % 2 === 0 ? x * x : null)      .filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>[1, 2, 3, 4]    .map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))

    .map(x => x % 2 === 0 ? x * x : null)
>map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>x : Symbol(x, Decl(inferTypePredicates.ts, 15, 9))
>x : Symbol(x, Decl(inferTypePredicates.ts, 15, 9))
>x : Symbol(x, Decl(inferTypePredicates.ts, 15, 9))
>x : Symbol(x, Decl(inferTypePredicates.ts, 15, 9))

      .filter(isTruthy);
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>isTruthy : Symbol(isTruthy, Decl(inferTypePredicates.ts, 11, 5))

const evenSquaresNonNull: number[] =  // should ok
>evenSquaresNonNull : Symbol(evenSquaresNonNull, Decl(inferTypePredicates.ts, 18, 5))

    [1, 2, 3, 4]
>[1, 2, 3, 4]    .map(x => x % 2 === 0 ? x * x : null)    .filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>[1, 2, 3, 4]    .map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))

    .map(x => x % 2 === 0 ? x * x : null)
>map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>x : Symbol(x, Decl(inferTypePredicates.ts, 20, 9))
>x : Symbol(x, Decl(inferTypePredicates.ts, 20, 9))
>x : Symbol(x, Decl(inferTypePredicates.ts, 20, 9))
>x : Symbol(x, Decl(inferTypePredicates.ts, 20, 9))

    .filter(x => x !== null);
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>x : Symbol(x, Decl(inferTypePredicates.ts, 21, 12))
>x : Symbol(x, Decl(inferTypePredicates.ts, 21, 12))

function isNonNull(x: number | null) {
>isNonNull : Symbol(isNonNull, Decl(inferTypePredicates.ts, 21, 29))
>x : Symbol(x, Decl(inferTypePredicates.ts, 23, 19))

  return x !== null;
>x : Symbol(x, Decl(inferTypePredicates.ts, 23, 19))
}

// factoring out a boolean works thanks to aliased discriminants
function isNonNullVar(x: number | null) {
>isNonNullVar : Symbol(isNonNullVar, Decl(inferTypePredicates.ts, 25, 1))
>x : Symbol(x, Decl(inferTypePredicates.ts, 28, 22))

  const ok = x !== null;
>ok : Symbol(ok, Decl(inferTypePredicates.ts, 29, 7))
>x : Symbol(x, Decl(inferTypePredicates.ts, 28, 22))

  return ok;
>ok : Symbol(ok, Decl(inferTypePredicates.ts, 29, 7))
}

function isNonNullGeneric<T>(x: T) {
>isNonNullGeneric : Symbol(isNonNullGeneric, Decl(inferTypePredicates.ts, 31, 1))
>T : Symbol(T, Decl(inferTypePredicates.ts, 33, 26))
>x : Symbol(x, Decl(inferTypePredicates.ts, 33, 29))
>T : Symbol(T, Decl(inferTypePredicates.ts, 33, 26))

  return x !== null;
>x : Symbol(x, Decl(inferTypePredicates.ts, 33, 29))
}

// Type guards can flow between functions
const myGuard = (o: string | undefined): o is string => !!o;
>myGuard : Symbol(myGuard, Decl(inferTypePredicates.ts, 38, 5))
>o : Symbol(o, Decl(inferTypePredicates.ts, 38, 17))
>o : Symbol(o, Decl(inferTypePredicates.ts, 38, 17))
>o : Symbol(o, Decl(inferTypePredicates.ts, 38, 17))

const mySecondGuard = (o: string | undefined) => myGuard(o);
>mySecondGuard : Symbol(mySecondGuard, Decl(inferTypePredicates.ts, 39, 5))
>o : Symbol(o, Decl(inferTypePredicates.ts, 39, 23))
>myGuard : Symbol(myGuard, Decl(inferTypePredicates.ts, 38, 5))
>o : Symbol(o, Decl(inferTypePredicates.ts, 39, 23))

// https://github.com/microsoft/TypeScript/issues/16069#issuecomment-1327449914
// This doesn't work because the false condition prevents type guard inference.
// Breaking up the filters does work.
type MyObj = { data?: string };
>MyObj : Symbol(MyObj, Decl(inferTypePredicates.ts, 39, 60))
>data : Symbol(data, Decl(inferTypePredicates.ts, 44, 14))

type MyArray = { list?: MyObj[] }[];
>MyArray : Symbol(MyArray, Decl(inferTypePredicates.ts, 44, 31))
>list : Symbol(list, Decl(inferTypePredicates.ts, 45, 16))
>MyObj : Symbol(MyObj, Decl(inferTypePredicates.ts, 39, 60))

const myArray: MyArray = [];
>myArray : Symbol(myArray, Decl(inferTypePredicates.ts, 46, 5))
>MyArray : Symbol(MyArray, Decl(inferTypePredicates.ts, 44, 31))

const result = myArray
>result : Symbol(result, Decl(inferTypePredicates.ts, 48, 5))
>myArray  .map((arr) => arr.list)  .filter((arr) => arr && arr.length)  .map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>myArray  .map((arr) => arr.list)  .filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>myArray  .map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>myArray : Symbol(myArray, Decl(inferTypePredicates.ts, 46, 5))

  .map((arr) => arr.list)
>map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 49, 8))
>arr.list : Symbol(list, Decl(inferTypePredicates.ts, 45, 16))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 49, 8))
>list : Symbol(list, Decl(inferTypePredicates.ts, 45, 16))

  .filter((arr) => arr && arr.length)
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 50, 11))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 50, 11))
>arr.length : Symbol(Array.length, Decl(lib.es5.d.ts, --, --))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 50, 11))
>length : Symbol(Array.length, Decl(lib.es5.d.ts, --, --))

  .map((arr) => arr // should error
>map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 51, 8))
>arr // should error    .filter((obj) => obj && obj.data)    .map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>arr // should error    .filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 51, 8))

    .filter((obj) => obj && obj.data)
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>obj : Symbol(obj, Decl(inferTypePredicates.ts, 52, 13))
>obj : Symbol(obj, Decl(inferTypePredicates.ts, 52, 13))
>obj.data : Symbol(data, Decl(inferTypePredicates.ts, 44, 14))
>obj : Symbol(obj, Decl(inferTypePredicates.ts, 52, 13))
>data : Symbol(data, Decl(inferTypePredicates.ts, 44, 14))

    .map(obj => JSON.parse(obj.data))  // should error
>map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>obj : Symbol(obj, Decl(inferTypePredicates.ts, 53, 9))
>JSON.parse : Symbol(JSON.parse, Decl(lib.es5.d.ts, --, --))
>JSON : Symbol(JSON, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>parse : Symbol(JSON.parse, Decl(lib.es5.d.ts, --, --))
>obj.data : Symbol(data, Decl(inferTypePredicates.ts, 44, 14))
>obj : Symbol(obj, Decl(inferTypePredicates.ts, 53, 9))
>data : Symbol(data, Decl(inferTypePredicates.ts, 44, 14))

  );

const result2 = myArray
>result2 : Symbol(result2, Decl(inferTypePredicates.ts, 56, 5))
>myArray  .map((arr) => arr.list)  .filter((arr) => !!arr)  .filter(arr => arr.length)  .map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>myArray  .map((arr) => arr.list)  .filter((arr) => !!arr)  .filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>myArray  .map((arr) => arr.list)  .filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>myArray  .map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>myArray : Symbol(myArray, Decl(inferTypePredicates.ts, 46, 5))

  .map((arr) => arr.list)
>map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 57, 8))
>arr.list : Symbol(list, Decl(inferTypePredicates.ts, 45, 16))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 57, 8))
>list : Symbol(list, Decl(inferTypePredicates.ts, 45, 16))

  .filter((arr) => !!arr)
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 58, 11))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 58, 11))

  .filter(arr => arr.length)
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 59, 10))
>arr.length : Symbol(Array.length, Decl(lib.es5.d.ts, --, --))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 59, 10))
>length : Symbol(Array.length, Decl(lib.es5.d.ts, --, --))

  .map((arr) => arr // should ok
>map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 60, 8))
>arr // should ok    .filter((obj) => obj)    // inferring a guard here would require https://github.com/microsoft/TypeScript/issues/42384    .filter(obj => !!obj.data)    .map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>arr // should ok    .filter((obj) => obj)    // inferring a guard here would require https://github.com/microsoft/TypeScript/issues/42384    .filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>arr // should ok    .filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>arr : Symbol(arr, Decl(inferTypePredicates.ts, 60, 8))

    .filter((obj) => obj)
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>obj : Symbol(obj, Decl(inferTypePredicates.ts, 61, 13))
>obj : Symbol(obj, Decl(inferTypePredicates.ts, 61, 13))

    // inferring a guard here would require https://github.com/microsoft/TypeScript/issues/42384
    .filter(obj => !!obj.data)
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>obj : Symbol(obj, Decl(inferTypePredicates.ts, 63, 12))
>obj.data : Symbol(data, Decl(inferTypePredicates.ts, 44, 14))
>obj : Symbol(obj, Decl(inferTypePredicates.ts, 63, 12))
>data : Symbol(data, Decl(inferTypePredicates.ts, 44, 14))

    .map(obj => JSON.parse(obj.data))
>map : Symbol(Array.map, Decl(lib.es5.d.ts, --, --))
>obj : Symbol(obj, Decl(inferTypePredicates.ts, 64, 9))
>JSON.parse : Symbol(JSON.parse, Decl(lib.es5.d.ts, --, --))
>JSON : Symbol(JSON, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>parse : Symbol(JSON.parse, Decl(lib.es5.d.ts, --, --))
>obj.data : Symbol(data, Decl(inferTypePredicates.ts, 44, 14))
>obj : Symbol(obj, Decl(inferTypePredicates.ts, 64, 9))
>data : Symbol(data, Decl(inferTypePredicates.ts, 44, 14))

  );

// https://github.com/microsoft/TypeScript/issues/16069#issuecomment-1183547889
type Foo = {
>Foo : Symbol(Foo, Decl(inferTypePredicates.ts, 65, 4))

  foo: string;
>foo : Symbol(foo, Decl(inferTypePredicates.ts, 68, 12))
}
type Bar = Foo & {
>Bar : Symbol(Bar, Decl(inferTypePredicates.ts, 70, 1))
>Foo : Symbol(Foo, Decl(inferTypePredicates.ts, 65, 4))

  bar: string;
>bar : Symbol(bar, Decl(inferTypePredicates.ts, 71, 18))
}

const list: (Foo | Bar)[] = [];
>list : Symbol(list, Decl(inferTypePredicates.ts, 75, 5))
>Foo : Symbol(Foo, Decl(inferTypePredicates.ts, 65, 4))
>Bar : Symbol(Bar, Decl(inferTypePredicates.ts, 70, 1))

const resultBar: Bar[] = list.filter((value) => 'bar' in value); // should ok
>resultBar : Symbol(resultBar, Decl(inferTypePredicates.ts, 76, 5))
>Bar : Symbol(Bar, Decl(inferTypePredicates.ts, 70, 1))
>list.filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>list : Symbol(list, Decl(inferTypePredicates.ts, 75, 5))
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>value : Symbol(value, Decl(inferTypePredicates.ts, 76, 38))
>value : Symbol(value, Decl(inferTypePredicates.ts, 76, 38))

// https://github.com/microsoft/TypeScript/issues/38390#issuecomment-626019466
// Ryan's example (currently legal):
const a = [1, "foo", 2, "bar"].filter(x => typeof x === "string");
>a : Symbol(a, Decl(inferTypePredicates.ts, 80, 5))
>[1, "foo", 2, "bar"].filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>filter : Symbol(Array.filter, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>x : Symbol(x, Decl(inferTypePredicates.ts, 80, 38))
>x : Symbol(x, Decl(inferTypePredicates.ts, 80, 38))

a.push(10);
>a.push : Symbol(Array.push, Decl(lib.es5.d.ts, --, --))
>a : Symbol(a, Decl(inferTypePredicates.ts, 80, 5))
>push : Symbol(Array.push, Decl(lib.es5.d.ts, --, --))

// Defer to explicit type guards, even when they're incorrect.
function backwardsGuard(x: number|string): x is number {
>backwardsGuard : Symbol(backwardsGuard, Decl(inferTypePredicates.ts, 81, 11))
>x : Symbol(x, Decl(inferTypePredicates.ts, 84, 24))
>x : Symbol(x, Decl(inferTypePredicates.ts, 84, 24))

  return typeof x === 'string';
>x : Symbol(x, Decl(inferTypePredicates.ts, 84, 24))
}

// Partition tests. The "false" case matters.
function isString(x: string | number) {
>isString : Symbol(isString, Decl(inferTypePredicates.ts, 86, 1))
>x : Symbol(x, Decl(inferTypePredicates.ts, 89, 18))

  return typeof x === 'string';
>x : Symbol(x, Decl(inferTypePredicates.ts, 89, 18))
}

declare let strOrNum: string | number;
>strOrNum : Symbol(strOrNum, Decl(inferTypePredicates.ts, 93, 11))

if (isString(strOrNum)) {
>isString : Symbol(isString, Decl(inferTypePredicates.ts, 86, 1))
>strOrNum : Symbol(strOrNum, Decl(inferTypePredicates.ts, 93, 11))

  let t: string = strOrNum; // should ok
>t : Symbol(t, Decl(inferTypePredicates.ts, 95, 5))
>strOrNum : Symbol(strOrNum, Decl(inferTypePredicates.ts, 93, 11))

} else {
  let t: number = strOrNum; // should ok
>t : Symbol(t, Decl(inferTypePredicates.ts, 97, 5))
>strOrNum : Symbol(strOrNum, Decl(inferTypePredicates.ts, 93, 11))
}

function flakyIsString(x: string | number) {
>flakyIsString : Symbol(flakyIsString, Decl(inferTypePredicates.ts, 98, 1))
>x : Symbol(x, Decl(inferTypePredicates.ts, 100, 23))

  return typeof x === 'string' && Math.random() > 0.5;
>x : Symbol(x, Decl(inferTypePredicates.ts, 100, 23))
>Math.random : Symbol(Math.random, Decl(lib.es5.d.ts, --, --))
>Math : Symbol(Math, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>random : Symbol(Math.random, Decl(lib.es5.d.ts, --, --))
}
if (flakyIsString(strOrNum)) {
>flakyIsString : Symbol(flakyIsString, Decl(inferTypePredicates.ts, 98, 1))
>strOrNum : Symbol(strOrNum, Decl(inferTypePredicates.ts, 93, 11))

  let t: string = strOrNum; // should error
>t : Symbol(t, Decl(inferTypePredicates.ts, 104, 5))
>strOrNum : Symbol(strOrNum, Decl(inferTypePredicates.ts, 93, 11))

} else {
  let t: number = strOrNum;  // should error
>t : Symbol(t, Decl(inferTypePredicates.ts, 106, 5))
>strOrNum : Symbol(strOrNum, Decl(inferTypePredicates.ts, 93, 11))
}

function isDate(x: object): x is Date {
>isDate : Symbol(isDate, Decl(inferTypePredicates.ts, 107, 1))
>x : Symbol(x, Decl(inferTypePredicates.ts, 109, 16))
>x : Symbol(x, Decl(inferTypePredicates.ts, 109, 16))
>Date : Symbol(Date, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.scripthost.d.ts, --, --))

  return x instanceof Date;
>x : Symbol(x, Decl(inferTypePredicates.ts, 109, 16))
>Date : Symbol(Date, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.scripthost.d.ts, --, --))
}
function flakyIsDate(x: object): x is Date {
>flakyIsDate : Symbol(flakyIsDate, Decl(inferTypePredicates.ts, 111, 1))
>x : Symbol(x, Decl(inferTypePredicates.ts, 112, 21))
>x : Symbol(x, Decl(inferTypePredicates.ts, 112, 21))
>Date : Symbol(Date, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.scripthost.d.ts, --, --))

  return x instanceof Date;
>x : Symbol(x, Decl(inferTypePredicates.ts, 112, 21))
>Date : Symbol(Date, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.scripthost.d.ts, --, --))
}

declare let maybeDate: object;
>maybeDate : Symbol(maybeDate, Decl(inferTypePredicates.ts, 116, 11))

if (isDate(maybeDate)) {
>isDate : Symbol(isDate, Decl(inferTypePredicates.ts, 107, 1))
>maybeDate : Symbol(maybeDate, Decl(inferTypePredicates.ts, 116, 11))

  let t: Date = maybeDate; // should ok
>t : Symbol(t, Decl(inferTypePredicates.ts, 118, 5))
>Date : Symbol(Date, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.scripthost.d.ts, --, --))
>maybeDate : Symbol(maybeDate, Decl(inferTypePredicates.ts, 116, 11))

} else {
  let t: object = maybeDate;  // should ok
>t : Symbol(t, Decl(inferTypePredicates.ts, 120, 5))
>maybeDate : Symbol(maybeDate, Decl(inferTypePredicates.ts, 116, 11))
}

if (flakyIsDate(maybeDate)) {
>flakyIsDate : Symbol(flakyIsDate, Decl(inferTypePredicates.ts, 111, 1))
>maybeDate : Symbol(maybeDate, Decl(inferTypePredicates.ts, 116, 11))

  let t: Date = maybeDate; // should ok
>t : Symbol(t, Decl(inferTypePredicates.ts, 124, 5))
>Date : Symbol(Date, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --), Decl(lib.scripthost.d.ts, --, --))
>maybeDate : Symbol(maybeDate, Decl(inferTypePredicates.ts, 116, 11))

} else {
  let t: object = maybeDate;  // should ok
>t : Symbol(t, Decl(inferTypePredicates.ts, 126, 5))
>maybeDate : Symbol(maybeDate, Decl(inferTypePredicates.ts, 116, 11))
}

// This should not infer a type guard since the value on which we do the refinement
// is not related to the original parameter.
function irrelevantIsNumber(x: string | number) {
>irrelevantIsNumber : Symbol(irrelevantIsNumber, Decl(inferTypePredicates.ts, 127, 1))
>x : Symbol(x, Decl(inferTypePredicates.ts, 131, 28))

	x = Math.random() < 0.5 ? "string" : 123;
>x : Symbol(x, Decl(inferTypePredicates.ts, 131, 28))
>Math.random : Symbol(Math.random, Decl(lib.es5.d.ts, --, --))
>Math : Symbol(Math, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>random : Symbol(Math.random, Decl(lib.es5.d.ts, --, --))

  return typeof x === 'string';
>x : Symbol(x, Decl(inferTypePredicates.ts, 131, 28))
}
function irrelevantIsNumberDestructuring(x: string | number) {
>irrelevantIsNumberDestructuring : Symbol(irrelevantIsNumberDestructuring, Decl(inferTypePredicates.ts, 134, 1))
>x : Symbol(x, Decl(inferTypePredicates.ts, 135, 41))

	[x] = [Math.random() < 0.5 ? "string" : 123];
>x : Symbol(x, Decl(inferTypePredicates.ts, 135, 41))
>Math.random : Symbol(Math.random, Decl(lib.es5.d.ts, --, --))
>Math : Symbol(Math, Decl(lib.es5.d.ts, --, --), Decl(lib.es5.d.ts, --, --))
>random : Symbol(Math.random, Decl(lib.es5.d.ts, --, --))

  return typeof x === 'string';
>x : Symbol(x, Decl(inferTypePredicates.ts, 135, 41))
}

// We shouldn't infer a type guard for either param because of the negative case.
function areBothNums(x: string|number, y: string|number) {
>areBothNums : Symbol(areBothNums, Decl(inferTypePredicates.ts, 138, 1))
>x : Symbol(x, Decl(inferTypePredicates.ts, 141, 21))
>y : Symbol(y, Decl(inferTypePredicates.ts, 141, 38))

  return typeof x === 'number' && typeof y === 'number';
>x : Symbol(x, Decl(inferTypePredicates.ts, 141, 21))
>y : Symbol(y, Decl(inferTypePredicates.ts, 141, 38))
}

// It would be valid to infer a type guard for this function, but it would require some
// unification across the two return statements.
function doubleReturn(x: string|number) {
>doubleReturn : Symbol(doubleReturn, Decl(inferTypePredicates.ts, 143, 1))
>x : Symbol(x, Decl(inferTypePredicates.ts, 147, 22))

  if (typeof x === 'string') {
>x : Symbol(x, Decl(inferTypePredicates.ts, 147, 22))

    return true;
  }
  return false;
}

function guardsOneButNotOthers(a: string|number, b: string|number, c: string|number) {
>guardsOneButNotOthers : Symbol(guardsOneButNotOthers, Decl(inferTypePredicates.ts, 152, 1))
>a : Symbol(a, Decl(inferTypePredicates.ts, 154, 31))
>b : Symbol(b, Decl(inferTypePredicates.ts, 154, 48))
>c : Symbol(c, Decl(inferTypePredicates.ts, 154, 66))

  return typeof b === 'string';
>b : Symbol(b, Decl(inferTypePredicates.ts, 154, 48))
}

function dunderguard(__x: number | string) {
>dunderguard : Symbol(dunderguard, Decl(inferTypePredicates.ts, 156, 1))
>__x : Symbol(__x, Decl(inferTypePredicates.ts, 158, 21))

  return typeof __x  === 'string';
>__x : Symbol(__x, Decl(inferTypePredicates.ts, 158, 21))
}

// could infer a type guard here but it doesn't seem that helpful.
const booleanIdentity = (x: boolean) => x;
>booleanIdentity : Symbol(booleanIdentity, Decl(inferTypePredicates.ts, 163, 5))
>x : Symbol(x, Decl(inferTypePredicates.ts, 163, 25))
>x : Symbol(x, Decl(inferTypePredicates.ts, 163, 25))

// can infer "x is number | true"; debateable whether that's helpful.
const numOrBoolean = (x: number | boolean) => typeof x !== 'number' && x;
>numOrBoolean : Symbol(numOrBoolean, Decl(inferTypePredicates.ts, 166, 5))
>x : Symbol(x, Decl(inferTypePredicates.ts, 166, 22))
>x : Symbol(x, Decl(inferTypePredicates.ts, 166, 22))
>x : Symbol(x, Decl(inferTypePredicates.ts, 166, 22))

// inferred guards in methods
interface NumberInferrer {
>NumberInferrer : Symbol(NumberInferrer, Decl(inferTypePredicates.ts, 166, 73))

  isNumber(x: number | string): x is number;
>isNumber : Symbol(NumberInferrer.isNumber, Decl(inferTypePredicates.ts, 169, 26))
>x : Symbol(x, Decl(inferTypePredicates.ts, 170, 11))
>x : Symbol(x, Decl(inferTypePredicates.ts, 170, 11))
}
class Inferrer implements NumberInferrer {
>Inferrer : Symbol(Inferrer, Decl(inferTypePredicates.ts, 171, 1))
>NumberInferrer : Symbol(NumberInferrer, Decl(inferTypePredicates.ts, 166, 73))

  isNumber(x: number | string) { // should ok
>isNumber : Symbol(Inferrer.isNumber, Decl(inferTypePredicates.ts, 172, 42))
>x : Symbol(x, Decl(inferTypePredicates.ts, 173, 11))

    return typeof x === 'number';
>x : Symbol(x, Decl(inferTypePredicates.ts, 173, 11))
  }
}
declare let numOrStr: number | string;
>numOrStr : Symbol(numOrStr, Decl(inferTypePredicates.ts, 177, 11))

const inf = new Inferrer();
>inf : Symbol(inf, Decl(inferTypePredicates.ts, 178, 5))
>Inferrer : Symbol(Inferrer, Decl(inferTypePredicates.ts, 171, 1))

if (inf.isNumber(numOrStr)) {
>inf.isNumber : Symbol(Inferrer.isNumber, Decl(inferTypePredicates.ts, 172, 42))
>inf : Symbol(inf, Decl(inferTypePredicates.ts, 178, 5))
>isNumber : Symbol(Inferrer.isNumber, Decl(inferTypePredicates.ts, 172, 42))
>numOrStr : Symbol(numOrStr, Decl(inferTypePredicates.ts, 177, 11))

  let t: number = numOrStr; // should ok
>t : Symbol(t, Decl(inferTypePredicates.ts, 180, 5))
>numOrStr : Symbol(numOrStr, Decl(inferTypePredicates.ts, 177, 11))

} else {
  let t: string = numOrStr; // should ok
>t : Symbol(t, Decl(inferTypePredicates.ts, 182, 5))
>numOrStr : Symbol(numOrStr, Decl(inferTypePredicates.ts, 177, 11))
}

