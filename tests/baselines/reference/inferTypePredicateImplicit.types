//// [tests/cases/compiler/inferTypePredicateImplicit.ts] ////

=== inferTypePredicateImplicit.ts ===
function isNonNull(x: number | null) {
>isNonNull : (x: number | null) => x is number
>x : number | null

  const ok = x !== null;
>ok : boolean
>x !== null : boolean
>x : number | null

  return ok;
>ok : boolean
}

declare let tNN: number | null;
>tNN : number | null

if (isNonNull(tNN)) {
>isNonNull(tNN) : boolean
>isNonNull : (x: number | null) => x is number
>tNN : number | null

  let t: number = tNN;
>t : number
>tNN : number
}

// Should not infer a type predicate for this function.
// true return => x is string, but false return !=> x is number
function flakyIsString(x: string | number) {
>flakyIsString : (x: string | number) => boolean
>x : string | number

  return typeof x === 'string' && Math.random() > 0.5;
>typeof x === 'string' && Math.random() > 0.5 : boolean
>typeof x === 'string' : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : string | number
>'string' : "string"
>Math.random() > 0.5 : boolean
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number
>0.5 : 0.5
}

function isNonNullExplicit(x: number | null) {
>isNonNullExplicit : (x: number | null) => x is number
>x : number | null

  const ok = x !== null;
>ok : boolean
>x !== null : boolean
>x : number | null

  if (ok) {
>ok : boolean

    let t: number = x;
>t : number
>x : number
  }
  return ok;
>ok : boolean
}

