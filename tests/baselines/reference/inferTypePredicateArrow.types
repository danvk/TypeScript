//// [tests/cases/compiler/inferTypePredicateArrow.ts] ////

=== inferTypePredicateArrow.ts ===
// https://github.com/microsoft/TypeScript/issues/16069

const numsOrNull = [1, 2, 3, 4, null];
>numsOrNull : (number | null)[]
>[1, 2, 3, 4, null] : (number | null)[]
>1 : 1
>2 : 2
>3 : 3
>4 : 4

const filteredNums = numsOrNull.filter(x => !!x);
>filteredNums : (number | null)[]
>numsOrNull.filter(x => !!x) : (number | null)[]
>numsOrNull.filter : { <S extends number | null>(predicate: (value: number | null, index: number, array: (number | null)[]) => value is S, thisArg?: any): S[]; (predicate: (value: number | null, index: number, array: (number | null)[]) => unknown, thisArg?: any): (number | null)[]; }
>numsOrNull : (number | null)[]
>filter : { <S extends number | null>(predicate: (value: number | null, index: number, array: (number | null)[]) => value is S, thisArg?: any): S[]; (predicate: (value: number | null, index: number, array: (number | null)[]) => unknown, thisArg?: any): (number | null)[]; }
>x => !!x : (x: number | null) => boolean
>x : number | null
>!!x : boolean
>!x : boolean
>x : number | null

const evenSquaresInline: number[] =
>evenSquaresInline : number[]

    [1, 2, 3, 4]
>[1, 2, 3, 4]        .map(x => x % 2 === 0 ? x * x : null)        .filter(x => !!x) : (number | null)[]
>[1, 2, 3, 4]        .map(x => x % 2 === 0 ? x * x : null)        .filter : { <S extends number | null>(predicate: (value: number | null, index: number, array: (number | null)[]) => value is S, thisArg?: any): S[]; (predicate: (value: number | null, index: number, array: (number | null)[]) => unknown, thisArg?: any): (number | null)[]; }
>[1, 2, 3, 4]        .map(x => x % 2 === 0 ? x * x : null) : (number | null)[]
>[1, 2, 3, 4]        .map : <U>(callbackfn: (value: number, index: number, array: number[]) => U, thisArg?: any) => U[]
>[1, 2, 3, 4] : number[]
>1 : 1
>2 : 2
>3 : 3
>4 : 4

        .map(x => x % 2 === 0 ? x * x : null)
>map : <U>(callbackfn: (value: number, index: number, array: number[]) => U, thisArg?: any) => U[]
>x => x % 2 === 0 ? x * x : null : (x: number) => number | null
>x : number
>x % 2 === 0 ? x * x : null : number | null
>x % 2 === 0 : boolean
>x % 2 : number
>x : number
>2 : 2
>0 : 0
>x * x : number
>x : number
>x : number

        .filter(x => !!x);
>filter : { <S extends number | null>(predicate: (value: number | null, index: number, array: (number | null)[]) => value is S, thisArg?: any): S[]; (predicate: (value: number | null, index: number, array: (number | null)[]) => unknown, thisArg?: any): (number | null)[]; }
>x => !!x : (x: number | null) => boolean
>x : number | null
>!!x : boolean
>!x : boolean
>x : number | null

// const isTruthy = (x: number | null) => { return !!x; };
const isTruthy = (x: number | null) => !!x;
>isTruthy : (x: number | null) => boolean
>(x: number | null) => !!x : (x: number | null) => boolean
>x : number | null
>!!x : boolean
>!x : boolean
>x : number | null

const evenSquares: number[] =
>evenSquares : number[]

    [1, 2, 3, 4]
>[1, 2, 3, 4]    .map(x => x % 2 === 0 ? x * x : null)      .filter(isTruthy) : (number | null)[]
>[1, 2, 3, 4]    .map(x => x % 2 === 0 ? x * x : null)      .filter : { <S extends number | null>(predicate: (value: number | null, index: number, array: (number | null)[]) => value is S, thisArg?: any): S[]; (predicate: (value: number | null, index: number, array: (number | null)[]) => unknown, thisArg?: any): (number | null)[]; }
>[1, 2, 3, 4]    .map(x => x % 2 === 0 ? x * x : null) : (number | null)[]
>[1, 2, 3, 4]    .map : <U>(callbackfn: (value: number, index: number, array: number[]) => U, thisArg?: any) => U[]
>[1, 2, 3, 4] : number[]
>1 : 1
>2 : 2
>3 : 3
>4 : 4

    .map(x => x % 2 === 0 ? x * x : null)
>map : <U>(callbackfn: (value: number, index: number, array: number[]) => U, thisArg?: any) => U[]
>x => x % 2 === 0 ? x * x : null : (x: number) => number | null
>x : number
>x % 2 === 0 ? x * x : null : number | null
>x % 2 === 0 : boolean
>x % 2 : number
>x : number
>2 : 2
>0 : 0
>x * x : number
>x : number
>x : number

      .filter(isTruthy);
>filter : { <S extends number | null>(predicate: (value: number | null, index: number, array: (number | null)[]) => value is S, thisArg?: any): S[]; (predicate: (value: number | null, index: number, array: (number | null)[]) => unknown, thisArg?: any): (number | null)[]; }
>isTruthy : (x: number | null) => boolean

const evenSquaresNonNull: number[] =
>evenSquaresNonNull : number[]

    [1, 2, 3, 4]
>[1, 2, 3, 4]    .map(x => x % 2 === 0 ? x * x : null)    .filter(x => x !== null) : number[]
>[1, 2, 3, 4]    .map(x => x % 2 === 0 ? x * x : null)    .filter : { <S extends number | null>(predicate: (value: number | null, index: number, array: (number | null)[]) => value is S, thisArg?: any): S[]; (predicate: (value: number | null, index: number, array: (number | null)[]) => unknown, thisArg?: any): (number | null)[]; }
>[1, 2, 3, 4]    .map(x => x % 2 === 0 ? x * x : null) : (number | null)[]
>[1, 2, 3, 4]    .map : <U>(callbackfn: (value: number, index: number, array: number[]) => U, thisArg?: any) => U[]
>[1, 2, 3, 4] : number[]
>1 : 1
>2 : 2
>3 : 3
>4 : 4

    .map(x => x % 2 === 0 ? x * x : null)
>map : <U>(callbackfn: (value: number, index: number, array: number[]) => U, thisArg?: any) => U[]
>x => x % 2 === 0 ? x * x : null : (x: number) => number | null
>x : number
>x % 2 === 0 ? x * x : null : number | null
>x % 2 === 0 : boolean
>x % 2 : number
>x : number
>2 : 2
>0 : 0
>x * x : number
>x : number
>x : number

    .filter(x => x !== null);
>filter : { <S extends number | null>(predicate: (value: number | null, index: number, array: (number | null)[]) => value is S, thisArg?: any): S[]; (predicate: (value: number | null, index: number, array: (number | null)[]) => unknown, thisArg?: any): (number | null)[]; }
>x => x !== null : (x: number | null) => x is number
>x : number | null
>x !== null : boolean
>x : number | null

// Type guards can flow between functions
const myGuard = (o: string | undefined): o is string => !!o;
>myGuard : (o: string | undefined) => o is string
>(o: string | undefined): o is string => !!o : (o: string | undefined) => o is string
>o : string | undefined
>!!o : boolean
>!o : boolean
>o : string | undefined

const mySecondGuard = (o: string | undefined) => myGuard(o);
>mySecondGuard : (o: string | undefined) => o is string
>(o: string | undefined) => myGuard(o) : (o: string | undefined) => o is string
>o : string | undefined
>myGuard(o) : boolean
>myGuard : (o: string | undefined) => o is string
>o : string | undefined

// https://github.com/microsoft/TypeScript/issues/16069#issuecomment-1327449914
type MyObj = { data?: string };
>MyObj : { data?: string | undefined; }
>data : string | undefined

type MyArray = { list?: MyObj[] }[];
>MyArray : { list?: MyObj[] | undefined; }[]
>list : MyObj[] | undefined

const myArray: MyArray = [];
>myArray : MyArray
>[] : never[]

const result = myArray
>result : any[][]
>myArray  .map((arr) => arr.list)  .filter((arr) => arr && arr.length)  .map((arr) => arr//              ^^^ Object is possibly 'undefined'.    .filter((obj) => obj && obj.data)    .map(obj => JSON.parse(obj.data))//                         ^^^^^^^^ Type 'undefined' is not assignable to type 'string'.  ) : any[][]
>myArray  .map((arr) => arr.list)  .filter((arr) => arr && arr.length)  .map : <U>(callbackfn: (value: MyObj[] | undefined, index: number, array: (MyObj[] | undefined)[]) => U, thisArg?: any) => U[]
>myArray  .map((arr) => arr.list)  .filter((arr) => arr && arr.length) : (MyObj[] | undefined)[]
>myArray  .map((arr) => arr.list)  .filter : { <S extends MyObj[] | undefined>(predicate: (value: MyObj[] | undefined, index: number, array: (MyObj[] | undefined)[]) => value is S, thisArg?: any): S[]; (predicate: (value: MyObj[] | undefined, index: number, array: (MyObj[] | undefined)[]) => unknown, thisArg?: any): (MyObj[] | undefined)[]; }
>myArray  .map((arr) => arr.list) : (MyObj[] | undefined)[]
>myArray  .map : <U>(callbackfn: (value: { list?: MyObj[] | undefined; }, index: number, array: { list?: MyObj[] | undefined; }[]) => U, thisArg?: any) => U[]
>myArray : MyArray

  .map((arr) => arr.list)
>map : <U>(callbackfn: (value: { list?: MyObj[] | undefined; }, index: number, array: { list?: MyObj[] | undefined; }[]) => U, thisArg?: any) => U[]
>(arr) => arr.list : (arr: { list?: MyObj[] | undefined; }) => MyObj[] | undefined
>arr : { list?: MyObj[] | undefined; }
>arr.list : MyObj[] | undefined
>arr : { list?: MyObj[] | undefined; }
>list : MyObj[] | undefined

  .filter((arr) => arr && arr.length)
>filter : { <S extends MyObj[] | undefined>(predicate: (value: MyObj[] | undefined, index: number, array: (MyObj[] | undefined)[]) => value is S, thisArg?: any): S[]; (predicate: (value: MyObj[] | undefined, index: number, array: (MyObj[] | undefined)[]) => unknown, thisArg?: any): (MyObj[] | undefined)[]; }
>(arr) => arr && arr.length : (arr: MyObj[] | undefined) => number | undefined
>arr : MyObj[] | undefined
>arr && arr.length : number | undefined
>arr : MyObj[] | undefined
>arr.length : number
>arr : MyObj[]
>length : number

  .map((arr) => arr
>map : <U>(callbackfn: (value: MyObj[] | undefined, index: number, array: (MyObj[] | undefined)[]) => U, thisArg?: any) => U[]
>(arr) => arr//              ^^^ Object is possibly 'undefined'.    .filter((obj) => obj && obj.data)    .map(obj => JSON.parse(obj.data)) : (arr: MyObj[] | undefined) => any[]
>arr : MyObj[] | undefined
>arr//              ^^^ Object is possibly 'undefined'.    .filter((obj) => obj && obj.data)    .map(obj => JSON.parse(obj.data)) : any[]
>arr//              ^^^ Object is possibly 'undefined'.    .filter((obj) => obj && obj.data)    .map : <U>(callbackfn: (value: MyObj, index: number, array: MyObj[]) => U, thisArg?: any) => U[]
>arr//              ^^^ Object is possibly 'undefined'.    .filter((obj) => obj && obj.data) : MyObj[]
>arr//              ^^^ Object is possibly 'undefined'.    .filter : { <S extends MyObj>(predicate: (value: MyObj, index: number, array: MyObj[]) => value is S, thisArg?: any): S[]; (predicate: (value: MyObj, index: number, array: MyObj[]) => unknown, thisArg?: any): MyObj[]; }
>arr : MyObj[] | undefined

//              ^^^ Object is possibly 'undefined'.
    .filter((obj) => obj && obj.data)
>filter : { <S extends MyObj>(predicate: (value: MyObj, index: number, array: MyObj[]) => value is S, thisArg?: any): S[]; (predicate: (value: MyObj, index: number, array: MyObj[]) => unknown, thisArg?: any): MyObj[]; }
>(obj) => obj && obj.data : (obj: MyObj) => string | undefined
>obj : MyObj
>obj && obj.data : string | undefined
>obj : MyObj
>obj.data : string | undefined
>obj : MyObj
>data : string | undefined

    .map(obj => JSON.parse(obj.data))
>map : <U>(callbackfn: (value: MyObj, index: number, array: MyObj[]) => U, thisArg?: any) => U[]
>obj => JSON.parse(obj.data) : (obj: MyObj) => any
>obj : MyObj
>JSON.parse(obj.data) : any
>JSON.parse : (text: string, reviver?: ((this: any, key: string, value: any) => any) | undefined) => any
>JSON : JSON
>parse : (text: string, reviver?: ((this: any, key: string, value: any) => any) | undefined) => any
>obj.data : string | undefined
>obj : MyObj
>data : string | undefined

//                         ^^^^^^^^ Type 'undefined' is not assignable to type 'string'.
  );

// https://github.com/microsoft/TypeScript/issues/16069#issuecomment-1335186481

// https://github.com/microsoft/TypeScript/issues/16069#issuecomment-1183547889
type Foo = {
>Foo : { foo: string; }

  foo: string;
>foo : string
}
type Bar = Foo & {
>Bar : Foo & { bar: string; }

  bar: string;
>bar : string
}

const list: (Foo | Bar)[] = [];
>list : (Foo | Bar)[]
>[] : never[]

const resultBar = list.filter((value) => 'bar' in value);
>resultBar : Bar[]
>list.filter((value) => 'bar' in value) : Bar[]
>list.filter : { <S extends Foo | Bar>(predicate: (value: Foo | Bar, index: number, array: (Foo | Bar)[]) => value is S, thisArg?: any): S[]; (predicate: (value: Foo | Bar, index: number, array: (Foo | Bar)[]) => unknown, thisArg?: any): (Foo | Bar)[]; }
>list : (Foo | Bar)[]
>filter : { <S extends Foo | Bar>(predicate: (value: Foo | Bar, index: number, array: (Foo | Bar)[]) => value is S, thisArg?: any): S[]; (predicate: (value: Foo | Bar, index: number, array: (Foo | Bar)[]) => unknown, thisArg?: any): (Foo | Bar)[]; }
>(value) => 'bar' in value : (value: Foo | Bar) => value is Bar
>value : Foo | Bar
>'bar' in value : boolean
>'bar' : "bar"
>value : Foo | Bar

// result type should be `Bar[]`

// https://github.com/microsoft/TypeScript/issues/38390#issuecomment-626019466
// Ryan's example:
const a = [1, "foo", 2, "bar"].filter(x => typeof x === "string");
>a : string[]
>[1, "foo", 2, "bar"].filter(x => typeof x === "string") : string[]
>[1, "foo", 2, "bar"].filter : { <S extends string | number>(predicate: (value: string | number, index: number, array: (string | number)[]) => value is S, thisArg?: any): S[]; (predicate: (value: string | number, index: number, array: (string | number)[]) => unknown, thisArg?: any): (string | number)[]; }
>[1, "foo", 2, "bar"] : (string | number)[]
>1 : 1
>"foo" : "foo"
>2 : 2
>"bar" : "bar"
>filter : { <S extends string | number>(predicate: (value: string | number, index: number, array: (string | number)[]) => value is S, thisArg?: any): S[]; (predicate: (value: string | number, index: number, array: (string | number)[]) => unknown, thisArg?: any): (string | number)[]; }
>x => typeof x === "string" : (x: string | number) => x is string
>x : string | number
>typeof x === "string" : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : string | number
>"string" : "string"

// Currently legal
a.push(10);
>a.push(10) : number
>a.push : (...items: string[]) => number
>a : string[]
>push : (...items: string[]) => number
>10 : 10

// Defer to explicit type guards, even when they're incorrect.
function backwardsGuard(x: number|string): x is number {
>backwardsGuard : (x: number | string) => x is number
>x : string | number

  return typeof x === 'string';
>typeof x === 'string' : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : string | number
>'string' : "string"
}

// Partition tests. The "false" case matters.
declare function partition<T, R extends T>(
>partition : <T, R extends T>(els: T[], pred: (x: T) => x is R) => [R[], Exclude<T, R>[]]

  els: T[], pred: (x: T) => x is R
>els : T[]
>pred : (x: T) => x is R
>x : T

): [R[], Exclude<T, R>[]];

function isString(x: string | number) {
>isString : (x: string | number) => x is string
>x : string | number

  return typeof x === 'string';
>typeof x === 'string' : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : string | number
>'string' : "string"
}

declare let strsOrNums: (string|number)[];
>strsOrNums : (string | number)[]

const [strs1, nums1] = partition(strsOrNums, isString); // nums1 should be number[]
>strs1 : string[]
>nums1 : number[]
>partition(strsOrNums, isString) : [string[], number[]]
>partition : <T, R extends T>(els: T[], pred: (x: T) => x is R) => [R[], Exclude<T, R>[]]
>strsOrNums : (string | number)[]
>isString : (x: string | number) => x is string

function flakyIsString(x: string | number) {
>flakyIsString : (x: string | number) => boolean
>x : string | number

  return typeof x === 'string' && Math.random() > 0.5;
>typeof x === 'string' && Math.random() > 0.5 : boolean
>typeof x === 'string' : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : string | number
>'string' : "string"
>Math.random() > 0.5 : boolean
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number
>0.5 : 0.5
}
const [strs2, nums2] = partition(strsOrNums, flakyIsString); // nums2 should be (string|number)[]
>strs2 : (string | number)[]
>nums2 : never[]
>partition(strsOrNums, flakyIsString) : [(string | number)[], never[]]
>partition : <T, R extends T>(els: T[], pred: (x: T) => x is R) => [R[], Exclude<T, R>[]]
>strsOrNums : (string | number)[]
>flakyIsString : (x: string | number) => boolean

function isDate(x: object): x is Date {
>isDate : (x: object) => x is Date
>x : object

  return x instanceof Date;
>x instanceof Date : boolean
>x : object
>Date : DateConstructor
}
function flakyIsDate(x: object): x is Date {
>flakyIsDate : (x: object) => x is Date
>x : object

  return x instanceof Date;
>x instanceof Date : boolean
>x : object
>Date : DateConstructor
}

declare let maybeDates: object[];
>maybeDates : object[]

const [dates1, objs1] = partition(maybeDates, isDate); // should be [Date[], object[]]
>dates1 : Date[]
>objs1 : object[]
>partition(maybeDates, isDate) : [Date[], object[]]
>partition : <T, R extends T>(els: T[], pred: (x: T) => x is R) => [R[], Exclude<T, R>[]]
>maybeDates : object[]
>isDate : (x: object) => x is Date

const [dates2, objs2] = partition(maybeDates, flakyIsDate); // should be [Date[], object[]]
>dates2 : Date[]
>objs2 : object[]
>partition(maybeDates, flakyIsDate) : [Date[], object[]]
>partition : <T, R extends T>(els: T[], pred: (x: T) => x is R) => [R[], Exclude<T, R>[]]
>maybeDates : object[]
>flakyIsDate : (x: object) => x is Date

// This should not infer a type guard since the value on which we do the refinement
// is not related to the original parameter.
function irrelevantIsNumber(x: string | number) {
>irrelevantIsNumber : (x: string | number) => x is string
>x : string | number

	x = Math.random() < 0.5 ? "string" : 123;
>x = Math.random() < 0.5 ? "string" : 123 : "string" | 123
>x : string | number
>Math.random() < 0.5 ? "string" : 123 : "string" | 123
>Math.random() < 0.5 : boolean
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number
>0.5 : 0.5
>"string" : "string"
>123 : 123

  return typeof x === 'string';
>typeof x === 'string' : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : string | number
>'string' : "string"
}

