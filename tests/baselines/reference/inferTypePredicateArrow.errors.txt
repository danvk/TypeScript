inferTypePredicateArrow.ts(6,7): error TS2322: Type '(number | null)[]' is not assignable to type 'number[]'.
  Type 'number | null' is not assignable to type 'number'.
    Type 'null' is not assignable to type 'number'.
inferTypePredicateArrow.ts(14,7): error TS2322: Type '(number | null)[]' is not assignable to type 'number[]'.
inferTypePredicateArrow.ts(36,17): error TS18048: 'arr' is possibly 'undefined'.
inferTypePredicateArrow.ts(39,28): error TS2345: Argument of type 'string | undefined' is not assignable to parameter of type 'string'.
  Type 'undefined' is not assignable to type 'string'.
inferTypePredicateArrow.ts(61,8): error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
inferTypePredicateArrow.ts(83,46): error TS2345: Argument of type '(x: string | number) => boolean' is not assignable to parameter of type '(x: string | number) => x is string | number'.
  Signature '(x: string | number): boolean' must be a type predicate.


==== inferTypePredicateArrow.ts (6 errors) ====
    // https://github.com/microsoft/TypeScript/issues/16069
    
    const numsOrNull = [1, 2, 3, 4, null];
    const filteredNums = numsOrNull.filter(x => !!x);
    
    const evenSquaresInline: number[] =
          ~~~~~~~~~~~~~~~~~
!!! error TS2322: Type '(number | null)[]' is not assignable to type 'number[]'.
!!! error TS2322:   Type 'number | null' is not assignable to type 'number'.
!!! error TS2322:     Type 'null' is not assignable to type 'number'.
        [1, 2, 3, 4]
            .map(x => x % 2 === 0 ? x * x : null)
            .filter(x => !!x);
    
    // const isTruthy = (x: number | null) => { return !!x; };
    const isTruthy = (x: number | null) => !!x;
    
    const evenSquares: number[] =
          ~~~~~~~~~~~
!!! error TS2322: Type '(number | null)[]' is not assignable to type 'number[]'.
        [1, 2, 3, 4]
        .map(x => x % 2 === 0 ? x * x : null)
          .filter(isTruthy);
    
    const evenSquaresNonNull: number[] =
        [1, 2, 3, 4]
        .map(x => x % 2 === 0 ? x * x : null)
        .filter(x => x !== null);
    
    // Type guards can flow between functions
    const myGuard = (o: string | undefined): o is string => !!o;
    const mySecondGuard = (o: string | undefined) => myGuard(o);
    
    // https://github.com/microsoft/TypeScript/issues/16069#issuecomment-1327449914
    type MyObj = { data?: string };
    type MyArray = { list?: MyObj[] }[];
    const myArray: MyArray = [];
    
    const result = myArray
      .map((arr) => arr.list)
      .filter((arr) => arr && arr.length)
      .map((arr) => arr
                    ~~~
!!! error TS18048: 'arr' is possibly 'undefined'.
    //              ^^^ Object is possibly 'undefined'.
        .filter((obj) => obj && obj.data)
        .map(obj => JSON.parse(obj.data))
                               ~~~~~~~~
!!! error TS2345: Argument of type 'string | undefined' is not assignable to parameter of type 'string'.
!!! error TS2345:   Type 'undefined' is not assignable to type 'string'.
    //                         ^^^^^^^^ Type 'undefined' is not assignable to type 'string'.
      );
    
    // https://github.com/microsoft/TypeScript/issues/16069#issuecomment-1335186481
    
    // https://github.com/microsoft/TypeScript/issues/16069#issuecomment-1183547889
    type Foo = {
      foo: string;
    }
    type Bar = Foo & {
      bar: string;
    }
    
    const list: (Foo | Bar)[] = [];
    const resultBar = list.filter((value) => 'bar' in value);
    // result type should be `Bar[]`
    
    // https://github.com/microsoft/TypeScript/issues/38390#issuecomment-626019466
    // Ryan's example:
    const a = [1, "foo", 2, "bar"].filter(x => typeof x === "string");
    // Currently legal
    a.push(10);
           ~~
!!! error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.
    
    // Defer to explicit type guards, even when they're incorrect.
    function backwardsGuard(x: number|string): x is number {
      return typeof x === 'string';
    }
    
    // Partition tests. The "false" case matters.
    declare function partition<T, R extends T>(
      els: T[], pred: (x: T) => x is R
    ): [R[], Exclude<T, R>[]];
    
    function isString(x: string | number) {
      return typeof x === 'string';
    }
    
    declare let strsOrNums: (string|number)[];
    const [strs1, nums1] = partition(strsOrNums, isString); // nums1 should be number[]
    
    function flakyIsString(x: string | number) {
      return typeof x === 'string' && Math.random() > 0.5;
    }
    const [strs2, nums2] = partition(strsOrNums, flakyIsString); // nums2 should be (string|number)[]
                                                 ~~~~~~~~~~~~~
!!! error TS2345: Argument of type '(x: string | number) => boolean' is not assignable to parameter of type '(x: string | number) => x is string | number'.
!!! error TS2345:   Signature '(x: string | number): boolean' must be a type predicate.
    
    function isDate(x: object): x is Date {
      return x instanceof Date;
    }
    function flakyIsDate(x: object): x is Date {
      return x instanceof Date;
    }
    
    declare let maybeDates: object[];
    const [dates1, objs1] = partition(maybeDates, isDate); // should be [Date[], object[]]
    const [dates2, objs2] = partition(maybeDates, flakyIsDate); // should be [Date[], object[]]
    
    // This should not infer a type guard since the value on which we do the refinement
    // is not related to the original parameter.
    function irrelevantIsNumber(x: string | number) {
    	x = Math.random() < 0.5 ? "string" : 123;
      return typeof x === 'string';
    }
    